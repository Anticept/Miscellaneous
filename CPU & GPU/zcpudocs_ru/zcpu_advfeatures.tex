\chapter{Расширенные функции процессора} \label{advfeatures}

\section{Расширенное управление выполнением кода} \label{advexecution}
В этой секции детально описано выполнение инструкций процессором. Процессор выполняет функции последовательно, декодирует их, а затем записывает результат по нужным направлениям.

При выполнении инструкции регистр \reg{XEIP} указывает на начало инструкции, и является абсолютным адресом, в то время как регистр \reg{IP} увеличивается на единицу при чтении каждого следующего байта, и является относительным вокруг сегмента кода.

Процесс выполнения также увеличивает регистр \reg{TMR} на количество циклов, которые заняла данная инструкция. Регистр \reg{CODEBYTES} хранит полное количество байт кода которые уже были прочитаны.

\begin{verbatim}
//TMR = 170

MOV EAX,10; //Инструкции длиной в 1 цикл
ADD EAX,EBX;

//TMR = 172
\end{verbatim}

Декодер инструкций устанавливает регистр \reg{CPAGE} в номер текущей страницы (страница, с которой была прочитана инструкция), и регистр \reg{PPAGE} в номер страницы, на которой находилась предыдущая инструкция. \emph{Текущая страница определяется положением первого байта инструкции, которая сейчас выполняется}.

Когда значения \reg{CPAGE} и \reg{PPAGE} не равны друг-другу производиться проверка прав доступа. Выполнение перехода любого рода также вызовет подобную проверку, и сбросит значения обоих регистров \reg{CPAGE} и \reg{PPAGE} в номер страницы, на которую осуществлён переход.

Инструкции могут быть фиксированного, или разного размера, см. стр \pageref{localexec}.

Вот псевдокод декодера инструкций:

\singlespacing
\begin{verbatim}
// Вычислить абсолютный адрес выполняемой инструкции, установить текущую страницу
XEIP = IP + CS
SetCurrentPage(floor(XEIP/128))

// Не позволять выполнения если не внутри страницы ядра, или если
// вызов происходит не из страницы ядра
if (PCAP == 1) and (CurrentPage.Execute == 0) and 
   (PreviousPage.RunLevel <> 0) then
  Interrupt(14,CPAGE)
end

// Сброс флагов прерываний
INTR = 0
if NIF <> undefined then
  IF = NIF
  NIF = undefined
end

// Чтение инструкции и селектора RM
Opcode = Fetch()
RM = 0
isFixedSize = false

// Проверка, является ли инструкция фиксированного размера
if ((Opcode >= 2000) and (Opcode < 4000)) or
   ((Opcode >= 12000) and (Opcode < 14000)) then
  Opcode = Opcode - 2000
  isFixedSize = true
end

// Чтение селектора RM
if (OperandCount > 0) or
   (Precompile_Peek() == 0) or 
   (isFixedSize) then
  RM = Fetch()
end

// Если не удалось прочитать опкод/селектор RM то сообщить об ошибке
if INTR == 1 then
  IF = 1
  Interrupt(5,12)
end

// Проверка на возможность выполнения инструкции
if (PCAP == 1) and (CurrentPage.Runlevel > RunLevel[Opcode]) then
  Interrupt(13,Opcode)
end

// Декодирование селектора RM
dRM2 = floor(RM / 10000)
dRM1 = RM - dRM2*10000

// Сегментные префиксы по умолчанию (DS)
Segment1 = -4
Segment2 = -4

// Декодирование сегментных префиксов
if Opcode > 1000 then
  if Opcode > 10000 then
    Segment2 = Fetch()

    Opcode = Opcode-10000
    if Opcode > 1000 then
      Segment1 = Fetch()
      
      Opcode = Opcode-1000
      Segment1 <> Segment 2
    else
      if isFixedSize then
        Fetch()
      end
    end
  else
    Segment1 = Fetch()
    Opcode = Opcode-1000
    if isFixedSize then
      Fetch()
    end
  end
elseif isFixedSize then
  Fetch()
  Fetch()
end

// Если не удалось прочитать сегментные префиксы, сообщить об ошибке
if INTR == 1 then
  Interrupt(5,12)
end

// Проверка на правильность номера инструкции
if opcode is not valid then
  Interrupt(4,Opcode)
else
  // Прочитать дополнительные байты, если нужно
  if isFixedSize then
    OperandByte1 = Fetch()
    if INTR == 1 then 
      Interrupt(5,22)
    end
    OperandByte2 = Fetch()
    if INTR == 1 then 
      Interrupt(5,32)
    end
  else
    if OperandCount > 0 then
      if NeedFetchByte1 then
        OperandByte1 = Fetch()
        if INTR == 1 then 
          Interrupt(5,22)
        end
      end
      if OperandCount > 1 then
        if NeedFetchByte2 then
          OperandByte2 = Precompile_Fetch() or 0
          if INTR == 1 then
            Interrupt(5,32)
          end
        end
      end
    end
  end
  
  // Выполнить инструкцию
  Execute()

  // Записать результат назад, если нужно
  if OperandCount > 0 then
    WriteBack(1)
    if OperandCount > 1 then
      WriteBack(2)
    end
  end
end

// Обновить таймера и счётчики
CODEBYTES = CODEBYTES + Instruction_Size
TMR = TMR + Instrucion_Cycles
TIMER = TIMER + TimerDT

// Установить страницу как предыдущую
XEIP = IP + CS
SetPreviousPage(floor(XEIP/128))  
\end{verbatim}
\onehalfspacing

\section{Система страниц} \label{paging}
Процессор Zyelios CPU разделяет всю доступною память в страницы. Каждая страница имеет 128 байт в размере. Страницы нумеруются последовательно начиная с нуля, тоесть адреса 0 .. 127 принадлежат первой странице, 128 .. 255 второй, и так далее.

Каждая страница имеет собственную маску прав (т.е. возможность разрешения/запрета записи, чтения, выполнения) и уровень доступа.

Уровень доступа это число, которое используется для присвоения коду разных уровней доступа. Высокий уровень доступа соответствует коду уровня ядра, а нижние уровни доступа соответствуют коду пользователя. Уровень доступа - число между 0 и 255 включительно, и более высоким уровнем доступа есть тот, у которого меньшее число, ему присвоенное. Например уровень доступа 3 имеет больше прав чем уровень доступа 6.

Код, запускаемый из страницы с более низким уровнем доступа (т.е. большими правами) может читать и писать страницы более высокого уровня, но не наоборот.

\begin{verbatim}
SRL 1,12 //Установить уровень доступа страницы 1 в 12
//Страница 1 соответствует адресам 128..255

SPP 5,0 //Сделать страницу 5 читаемой
CPP 6,1 //Сделать страницу 6 не записываемой
CPP 7,2 //Предотвратить выполнение кода на странице 7
\end{verbatim}

Уровень доступа 0 - особый уровень, который обходит все проверки прав доступа. На этом уровне также допустимо использование некоторых привилегированных инструкций, например \reg{CPUSET}. Все остальные уровни доступа подчиняются проверкам прав.

Если страница помечена как не читаемая, то её можно прочитать только со страницы с более низким уровнем (более высокими правами), аналогично для записи. Если страница помечена как запрещённая к выполнению, то на неё можно перейти только с уровня доступа 0.

Каждую страницу можно отобразить в другую страницу памяти. Это значит, что каждый раз как процессор будет пытаться писать или читать в эту страницу, данные на самом деле будут прочитаны с отображённой страницы. Любая страница может быть отображена.

\begin{verbatim}
MOV #130,1234 //Установить ячейку 2 страницы 1 в 1234
SMAP 0,1 //Отобразить страницу 0 в страницу 1
MOV EAX,#2 //Прочитать ячейку 2 страницы 0 (но на самом деле прочитать со страницы 1)
//EAX теперь равен 1234
\end{verbatim}

Настройки отображения и прав доступа хранятся в \emph{таблице страниц}. Таблица страниц активна когда процессор находиться в режиме расширенной работы с памятью (флаг \reg{MF} установлен в 1). Если флаг обнулён, то таблица страниц будет храниться внутри процессора. При этом проверки доступа производятся лишь кода процессор находиться в расширеном режиме (флаг \reg{EF}).

Внутренний регистр \reg{PTBL} хранит \emph{абсолютный} указатель на начало таблицы страниц, а в регистре \reg{PTBE} записано количество записей в таблице. Есть возможность менять таблицу прямо во время выполнения программы.

Каждая запись в таблице имеет 2 байта в размере. Первая запись (запись номер 0) это страница по умолчанию. Все остальные записи в таблице соответствуют страницам памяти.

Если адрес, к которому идёт обращение, не имеет соответствующей записи для страницы, на которой он находиться, то он будет использовать права и флаги, которые заданы страницей по умолчанию (нулевой записью в таблице страниц). При этом будет не доступно отображение в память.

Первый байт записи хранит флаги страницы и её уровень доступа. Второй байт хранит номер страницы, в которую эта страница должна быть отображена. Флаги доступа в записи страницы \emph{инвертированы}, то есть 1 значит запрет, а 0 значит разрешение.

Вот пример настройки таблицы страниц:
\begin{verbatim}
PageTable:
  alloc 513*2 //512 записей страниц + страница по умолчанию (64КБ памяти)
  
  .....
  
//Установить таблицу страниц
CPUSET 37,PageTable //PTBL
CPUSET 38,512 //PTBE

//Включить режим расширенной памяти
STM

//Непрямая работа с таблицей
SMAP 0,1 //Отобразить страницу 0 в 1
SPP 5,0 //Установить флаг страницы 5

//Прямое обращение к таблицу
MOV ESI,PageTable; //Сдвиг таблицы
MOV ESI:#0,0xE0; //Установить разрешения для страницы по умолчанию
MOV ESI:#2,1; //Отключить страницу 0
MOV ESI:#5,10; //Отобразить страницу 1 в 10
\end{verbatim}

Первый байт записи в таблице:

\singlespacing
\begin{longtable}{|c|p{4.0in}|} \hline
Бит & Описание \\ \hline
\texttt{00} & Отключена ли страница? 1 если это так \\ \hline
\texttt{01} & Отображена ли страница? 1 если это так \\ \hline
\texttt{02} & Страница генерирует внешнее прерывание 30 при обращении \\ \hline
\texttt{03} & Страница генерирует внешние прерывания 28, 29\\ \hline
\texttt{04} & Зарезервированный бит \\ \hline
\texttt{05} & Доступ на чтение (0: разрешено, 1: запрещено) \\ \hline
\texttt{06} & Доступ на запись (0: разрешено, 1: запрещено) \\ \hline
\texttt{07} & Доступ на выполнение (0: разрешено, 1: запрещено) \\ \hline
\texttt{08..15} & Уровень доступа \\ \hline
\end{longtable}
\onehalfspacing

Отключенные страницы будут вызывать ошибку памяти при попытке чтения любого адреса в них находящегося (так будто бы эта страница не находилась в адресном пространстве процессора). Отображённые страницы используют второй байт как номер \emph{физической} страницы, в которую происходит отображение.

Возможно отлавливать доступ к странице используя биты 2 и/или 3. Это будет вызывать внешние прерывания 28 (чтение), 29 (запись), 30 (доступ) каждый раз, когда идёт обращение к странице. Номер страницы, к которой идёт доступ будет передан как параметр (для прерывания 30), и сохранён адрес обращения. Это можно использовать для переопределения операций чтения/записи (см. стр \pageref{memoverride} для более подробной информации).

При обработке прерываний используется специальное правило. Права на вызов прерываний определяются уровнем доступа таблицы прерываний. Это значит что можно ограничить пользовательскую программу от вызова конкретных прерываний. Это работает будто-бы вызов происходил с помощью инструкции \reg{CALL} с адреса, на котором находиться прерывание. Это даёт возможность использовать прерывания для интерфейса между двумя частями кода с разными правами доступа.

\begin{verbatim}
STEF //Включить расширенный режим
LIDTR 2048 //Таблица прерываний на страницах 16-23

SRL 16,0 //Установить уровень доступа прерываний 0..31 в 0
SRL 17,1 //Установить уровень доступа прерываний 32..63 в 1
SRL 18,2 //Установить уровень доступа прерываний 64..95 в 2
SRL 19,3 //Установить уровень доступа прерываний 96..127 в 3
\end{verbatim}

Текущая страница при выполнении инструкций определяется регистром \reg{CPAGE}. \emph{Вообще текущая страница определяется только положением первого байта инструкции, которая сейчас выполняется}. Система страниц производит проверки когда регистр \reg{PPAGE} (значение \reg{CPAGE} для предыдущей инструкции) не совпадает по значению с \reg{CPAGE} (т.е. происходит переход через границу страниц).

Любой переход также вызовет подобную проверку, и сбросит значения регистров \reg{CPAGE} и \reg{PPAGE} в номер новой страницы.

Пересечь границу между страницами, или совершить прямой переход, возможно лишь если флаги следующей страницы (целевой страницы перехода) позволяют выполнение кода на той странице, либо если предыдущая страница имеет нулевой уровень доступа.

Весь внешний доступ к памяти процессора через его шину будет производить проверки чтения/записи. Уровень доступа для внешних операций ввода/вывода определяется регистром \reg{XTRL} (внешний уровень доступа). По умолчанию все внешние операции имеют уровень доступа 0.

Что-бы подытожить, вот те проверки, которые производятся системой страниц (но только в расширенном режиме):
\begin{itemize}
	\item Проверка перехода границ страницы
	\item Проверка при прямом переходе по адресу
  \item Проверки на права доступа к таблице прерываний
	\item Доступ к памяти на чтение/запись
	\item Внешний доступ к памяти/шине процессора
	\item Логика отображения страниц при записи/чтении
	\item Перехват доступа к странице
\end{itemize}

\section{Внутренняя память}
Для процессора Zyelios CPU можно настроить внутреннюю оперативную и постоянную память. Это позволяет сохранять программу прямо внутри процессора. Содержимое постоянной памяти будет скопировано в оперативную память при каждом сбросе состояния процессора. В постоянную память также можно программно писать, и стирать данные.

Всего есть три инструкции для работы с внутренней памятью: \reg{ERPG} (стереть страницу постоянной памяти), \reg{WRPG} (записать страницу постоянной памяти), \reg{RDPG} (прочитать страницу постоянной памяти).

Примеры использования:
\begin{verbatim}
ERPG 4 //Стирает данные из постоянной памяти
WRPG 4 //Записывает страницу 4 в постоянную память
       //После сброса процессора она будет восстановлена
RDPG 4 //Восстановить страницу 4 из постоянной памяти

ORG 512 //Разместить переменные на странице 4
SOME_AREA:
 ... данные ...
\end{verbatim}

\section{Побитовые операции}
ZCPU может работать с целыми числами разной ширины. Он поддерживает 8, 16, 32, и 48 битные целые числа, и имеет дополнительный набор инструкций для работы с ними:  \reg{BAND}, \reg{BOR}, \reg{BXOR}, \reg{BSHL}, \reg{BSHR}, \reg{BNOT}. Например:
\begin{verbatim}
MOV  EAX,105 //1101001
BAND EAX,24  //0011000
//EAX = 8      0001000

BOR EAX,67   //1000011
//EAX = 75   //1001011

BXOR EAX,15  //0001111
//EAX = 68   //1000100

BSHL EAX,2
//EAX = 272  //100010000

BSHR EAX,4
//EAX = 17   //0010001

BNOT EAX
//EAX = -18  //111111111111111111101110
\end{verbatim}

Также есть дополнительные операции, которые работают с отдельными битами числа: \reg{BIT}, \reg{SBIT}, \reg{TBIT}, \reg{CBIT}.

Инструкция \reg{BIT} проверяет, установлен ли данный бит числа. Проверить результат этой операции можно используя условный переход:
\begin{verbatim}
MOV EAX,105
BIT EAX,0
JNZ LABEL //Переход удался, если бит не нулевой

BIT EAX,1
JNZ LABEL //Переход не удался, если бит нулевой
\end{verbatim}

Инструкции \reg{SBIT} и \reg{CBIT} выставляют или убирают определённый бит числа. Инструкция \reg{TBIT} меняет этот бит на противоположный:
\begin{verbatim}
MOV EAX,105 //1101001
SBIT EAX,1
//EAX = 107   1101011

CBIT EAX,6
//EAX = 43    0101011

TBIT EAX,0
//EAX = 42    0101010
\end{verbatim}

\section{Поддержка блоков в памяти}
Некоторые инструкции процессора поддерживают инструкцию \reg{BLOCK}, которая выполняется перед выполнением нужной инструкции. Она используется для указания блока, над которым будет действовать следующая инструкция, например можно задать права для целого блока памяти сразу:
\begin{verbatim}
BLOCK 1024,8192 //8-килобайтовый блок начиная с адреса 1024
SRL 0,4 //Выставить уровень доступа всего блока в 4
\end{verbatim}

Первый операнд инструкции \reg{BLOCK} указывает на абсолютное смещение в памяти с которого начинается блок (должен быть выровнен по краю страницы если используется для инструкций, которые работают со страницами), а второй операнд указывает на размер блока (если используется для работы со страницами, то размер тоже должен быть кратный размеру страницы).

Инструкция \reg{BLOCK} выставляет два внутренних регистра \reg{BlockStart}, \reg{BlockSize}. После выполнения инструкции, которая поддерживает выставление блоков это регистры будут сброшены обратно в 0.

Размер блока должен быть отличным от нуля, иначе инструкция не будет действовать.

\emph{Есть возможность возникновения прерывания между инструкцией \reg{BLOCK} и другой инструкцией}. Поэтому желательно не использовать инструкцию \reg{BLOCK} внутри обработчика прерывания, поскольку его состояние восстановлено не будет.

Данные инструкции поддерживают этот префикс: \reg{SPP}, \reg{CPP}, \reg{SRL}, \reg{SMAP}.

\section{Копирование, сдвиг, обмен больших блоков данных}
(MCOPY, MSHIFT, MXCHG)

\section{Поддержка стекового кадра}
(using EBP register, and ENTER/LEAVE opcodes)

\section{Прерывания/расширенный режим} \label{advancedinterrupts}
If an interrupt occurs while reading or writing to memory pointer specified by the operand the operation will ???.

The processor interrupt handler performs a variety of checks before turning the control over back to the execution.

The interrupt handler is fairly complex. The psuedocode for the interrupt handler is listed below:
\singlespacing
\begin{verbatim}
// Если прерывание включено, запретить любой обмен данными на шине
INTR = 1
BusLock = 1
  
// Выставить регистры
LINT = interruptNo
LADD = interruptParameter or XEIP

// Выдать сигнал прерывания на выход процессора
SignalError(interruptNo,LADD)
  
if IF == 1 then
  if EF == 1 then // Расширеный режим
    // Проверка границ
    if (interruptNo < 0) or (interruptNo > 255) then
      if not cascadeInterrupt then Interrupt(13,3) end
    end

    // Проверка границ таблицы прерываний
    if interruptNo > NIDT-1 then
      if interruptNo == 0 then Reset = 1 end
      if interruptNo == 1 then Clk = 0 end
    end

    // Вычислить смещение в таблице прерываний
    interruptOffset = IDTR + interruptNo*4

    // Отключить запрет на работу шины процессора
    BusLock = 0
    SetCurrentPage(interruptOffset)

    IF = 0
    INTR = 0
    IP    = ReadCell(interruptOffset+0)
    CS    = ReadCell(interruptOffset+1)
            ReadCell(interruptOffset+2)
    FLAGS = ReadCell(interruptOffset+3)
    IF = 1
    
    if INTR == 1 then
      if not cascadeInterrupt then Interrupt(13,2) end
    else
      INTR = 1
    end
    
    // Вызвать предыдущую страницу, правильно настроив
    // состояние страниц
    SetCurrentPage(XEIP)
    SetPrevPage(interruptOffset)
    BusLock = 1

    if isExternal and (FLAGS[6] <> 1) then
      if not cascadeInterrupt then Interrupt(13,4) end
    end
    
    if FLAGS[5] == 1 then
      // Записать данные о возврате
      BusLock = 0
      IF = 0
      INTR = 0
      Push(IP)
      Push(CS)
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,6) end
      else
        INTR = 1
      end
      BusLock = 1

      // Произвести переход
      IF = 0
      INTR = 0
      if FLAGS[4] == 0
      then Jump(IP,CS)
      else Jump(IP)
      end
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,7) end
      else
        INTR = 1
      end
      
      // Выставить CMPR
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    else
      if interruptNo == 0 then
        Reset()
      end
      if interruptNo == 1 then
        Clk = 0
      end
      if FLAGS[3] == 1 then
        CMPR = 1
      end
    end
  end
  
  if PF == 1 then // Расширенный режим (совместимости)
    // Проверка границ
    if (interruptNo < 0) or (interruptNo > 255) then
      if not cascadeInterrupt then Interrupt(13,3) end
    end
    
    // Проверка памяти
    if RAMSize < 512 then
      if not cascadeInterrupt then Interrupt(13,5) end
    end

    // Посчитать абсолютное смещение записи прерывания
    interruptOffset = IDTR + interruptNo*2
    
    if interruptOffset > RAMSize-2 then interruptOffset = RAMSize-2 end
    if interruptOffset < 0         then interruptOffset = 0 end
    
    interruptOffset = Memory[interruptOffset]
    interruptFlags = Memory[interruptOffset+1]
    if (interruptFlags == 32) or (interruptFlags == 96) then
      BusLock = 0
      IF = 0
      INTR = 0
      if (interruptNo == 4 ) or
         (interruptNo == 7 ) or
         (interruptNo == 9 ) or
         (interruptNo == 10) then
        Push(LADD)
      end
      if (interruptNo == 4 ) or
         (interruptNo == 31) then
        Push(LINT)
      end
      if Push(IP) and Push(XEIP) then
        Jump(interruptOffset)
      end
      IF = 1
      
      if INTR == 1 then
        if not cascadeInterrupt then Interrupt(13,6) end
      else
        INTR = 1
      end
      CMPR = 0
      BusLock = 1
    else
      if interruptNo == 1 then Clk = 0 end
      CMPR = 1
    end
  end
  
  if (PF == 0) and (EF == 0) then // Обычный режим
    if (interruptNo < 0) or (interruptNo > 255) or (interruptNo > NIDT-1) then
      // Прерывание не обработано
      Exit()
    end
    if interruptNo == 0 then Reset = 1 end
    if interruptNo ~= 31 then Clk = 0 end
  end
end
  
// Сделать возможным запись по шине процессора
BusLock = 0
\end{verbatim}
\onehalfspacing

\section{Внешние прерывания}
(NMI stuff)

\section{Перехват доступа к памяти} \label{memoverride}
(using page traps to override access to specific memory areas)

\section{Внутренний таймер}
В ZCPU есть внутренний таймер, который можно использовать для точного измерения времени выполнения кода. Таймер может быть также использован для вызова прерываний с регулярным интервалом.

Инструкция \reg{TIMER} возвращает значение внутреннего таймера в секундах:
\begin{verbatim}
TIMER EAX
//EAX теперь равен количеству секунд, прошедших с момента старта процессора
\end{verbatim}

Можно настроить таймер так, что-бы он вызывал внешнее прерывание после некоторого количества секунд, или циклов, настроив один из специальных регистров.

Регистр \reg{TimerMode} управляет режимом таймера. Если он установлен в 0, то таймер будет отключён. Если \reg{TimerMode} выставлен в 1, то как источник сигнала для таймера будет использован регистр \reg{TMR}, а если \reg{TimerMode} установлен в 2, то таймер будет использовать регистр \reg{TIMER}.

Регистром \reg{TimerRate} задаётся количество циклов или количество секунд, которые должны быть отсчитаны таймером перед вызовом следующего прерывания. Регистр \reg{TimerPrevTime} хранит предыдущее значение регистра \reg{TMR} или \reg{TIMER}, когда прерывание было вызвано прошлый раз.

Регистром \reg{TimerAddress} указывается номер внешнего прерывания, которое будет вызвано когда таймер сработает.

При изменении значения регистра \reg{TimerMode} значение \reg{TimerPrevTime} будет сброшено.

Вот пример, как настроить таймер:
\begin{verbatim}
CPUSET 65,90; //Вызов каждые 90 циклов
CPUSET 67,40; //Вызов внешнего прерывания #40

CPUSET 64,1;  //Включить таймер
\end{verbatim}

Также можно установить таймер на секунды:
\begin{verbatim}
CPUSET 65,1.5; //Вызов каждые 1.5 секунд
CPUSET 67,40;  //Вызов внешнего прерывания #40

CPUSET 64,2;   //Включить таймер
\end{verbatim}

Если нужна точность в интервалах между срабатываниями ми таймера, то можно сбросить значения предыдущего времени срабатывания таймера (если нужно):
\begin{verbatim}
ExternalInterrupt:
  CLI; //Отключить прерывания
  
  .....
  
  CPUGET EAX,29; //Прочитать счётчик циклов
  ADD EAX,4;     //Добавить 4 пропущенны[ цикла
  CPUSET 66,EAX; //Записать в последнее время срабатывания таймера
  
  STI; //Включить прерывания
EXTRET;
\end{verbatim}

Также можно просто перезапустить таймер:
\begin{verbatim}
ExternalInterrupt:
  CLI; //Отключить прерывания
  
  .....
  
  CPUSET 64,1; //Перезапустить таймер
  STI; //Включить прерывания
EXTRET;
\end{verbatim}

Если интервал таймера установлен в 0, а последнее время срабатывания находится позже чем текущее время, то таймер можно использовать для единократного вызова события через некоторое время.

\section{Векторное расширение}
(using VMODE,VADD,etc)

\section{Режим аппаратной отладки}
(Using hardware debug mode)

\section{Кеширование и оптимизации реального времени} \label{caching}
Процессор Zyelios CPU кеширует выполняемый микрокод для более быстрой работы. Это намного повышает скорость повторного исполнения кода, но при этом первый запуск этого блока кода будет использовать значительное количество циклов процессора. Более быстро выполняется код в циклах, которые много раз повторяются.

Некоторые ограничения, которые накладываются системой кеширования:
\begin{enumerate}
	\item При выполнении кешированого блока микрокода процессор использует временные скоростные регистры вместо настоящих. Настоящее значение регистра будет обновлено только после выполнения блока микрокода.
	\item Процессор кеширует инструкции первый раз когда они декодируются. Чтение или запись в память самим процессором могут обнулить кеш, но операции ввода-вывода других устройств в эту-же область не меняют кеша, создавая возможность выполнения несуществующего кода.
	\item В каждом кешированом блоке микрокода содержится до 24 инструкций. Если происходит переход по адресу, то выполнение обрывается заранее.
	\item Все операции чтения-записи могут быть задержаны на несколько циклов, или не выполнены вообще.
\end{enumerate}