\chapter{Функции процессора}

\section{Вступление}

Zyelios CPU - виртуальный процессор. Он был создан для для автоматизации устройств и машин, созданных с помощью Wiremod, а также для обучения основам низкоуровневого программирования, программирования на языке С (с выходом компилятора HL-ZASM).

Этот процессор по своей архитектуре и внутренней структуре очень сильно напоминает современные микроконтроллеры и процессоры общего назначения, которые используются в современных компьютерах. Он был первоначально основан на базе архитектуры \texttt{x86}, но имеет значительные отличия, например, ZCPU использует числа с плавающей точкой вместо целочисленной арифметики.

Процессор - сложная машина, и, подобно управлению настоящей машиной, требует навыков. Надо понимать, что, несмотря на большие возможности по использованию процессора, он работает по весьма простым логическим правилам. Все функции процессора созданы взаимодействием этих правил.

Данная книга служит краткой документацией по всем функциям и возможностям ZCPU, включая любые не очевидные особенности работы. Но здесь указаны лишь возможности по управлению процессором, эта книга не предназначена для вводного ознакомления с ним.

\section{Теория}
Процессоры были изобретены как следующий шаг развития аналоговых компьютеров. Первые процессоры были использованы для решения математических уравнений, расчёта физических моделей и обработки большого количества статистических данных.

Программа, которую выполняет процессор, разделена на инструкции. Каждая инструкция это простая операция, которая некоторым образом меняет состояние процессора, или любого из внешних устройств. Например:
\begin{verbatim}
MOV R0,100 //Занести 100 в регистр R0
ADD R0,R1 //Добавить R1 к R0
\end{verbatim}

Дополнительные параметры, которые передаются в инструкцию и некоторым образом задают её поведение, называются \emph{операндами}. У каждой инструкции может быть 0, 1  или 2 операнда. Первый операнд называется \emph{целевым} операндом, а второй - \emph{исходным}.

В результате выполнения инструкции результат может быть записан в первый операнд:
\begin{verbatim}
ADD R0,200; //R0 = R0 + 200
\end{verbatim}

\emph{Регистром} называется ячейка со значением, которая находится внутри процессора. Регистры могут быть регистрами \emph{общего назначения} и \emph{управляющими} (внутренними). Программист может любым образом использовать регистры общего назначения, например, для сохранения промежуточных результатов:
\begin{verbatim}
MOV R6,100;
MOV R7,R6;
\end{verbatim}

Управляющие регистры меняют состояние и режим работы процессора.

Внешние устройства и дополнительная память подключаются к процессору через шину данных/адресов. \emph{Шина данных/адресов} - это особое устройство, которое позволяет связывать несколько других устройств вместе и производить обмен данными между ними. В процессоре ZCPU есть две шины: \reg{MemBus} (шина внешней памяти), и \reg{IOBus} (шина ввода/вывода по портам). Каждая ячейка памяти на этих шинах адресуется целым числом - \emph{адресом}. Нету никакой принципиальной разницы между двумя вышеуказанными шинами процессора, но ячейки шины портов можно использовать как регистры процессора:
\begin{verbatim}
MOV R0,PORT0 //Считать ячейку 0 через шину портов
MOV [500],R0 //Записать в ячейку 500 через шину памяти
\end{verbatim}

Шина памяти расположена на положительных адресах, а шина портов расположена в отрицательных адресах процессора, и как-бы зеркально отражена относительно шины памяти. Например:
\begin{verbatim}
MOV R0,PORT0 //Считать ячейку 0 через шину портов
MOV R0,[-1] //Тоже самое
\end{verbatim}

В процессоре ZCPU есть поддержка нескольких моделей памяти, которые задают размер встроенной оперативной памяти, размер постоянной памяти, и тому подобное.

\section{Регистры общего назначения}
В процессоре есть 40 регистров общего назначения. Они разделяются на \emph{основные} и \emph{дополнительные}. Регистры основного набора - \reg{EAX}, \reg{EBX}, \reg{ECX}, \reg{EDX}, \reg{ESI}, \reg{EDI}, \reg{ESP} и \reg{EBP}. Регистры дополнительного набора нумеруются таким образом: \reg{R0}, \reg{R1}, ..., \reg{R31}.

Каждый регистр может хранить некоторое число, и его можно использовать для проведения арифметических операций. Но при этом регистр \reg{ESP} используется для работы стека процессора, и изменение его значения может привести к некорректной работе программы. Если используются возможности C, то \reg{EBP} также используется для сохранения указателя на стековый кадр функции, и его изменение вызовет ошибку программы.

Каждый регистр хранит одно 64-битное значение с плавающей точкой. Его значение может находиться в пределах от $-10^{1022}$ до $10^{1023}$, но при этом точность самих чисел ограничена 48 битами. Это упрощение отличает процессор ZCPU от реальных процессоров.

Использование регистров \emph{намного} быстрее использования памяти. В 10 версии процессора были добавлены 32 регистра общего назначения, сформировав дополнительный набор регистров для ускорения работы программ.

При сбросе состояния процессора все регистры, кроме \reg{ESP}, будут выставлены в 0. Если в текущей модели памяти процессора есть внутренняя встроенная память, то регистр указателя стека будет указывать на последнюю ячейку внутренней памяти процессора.

\section{Выполнение инструкций}
В процессоре ZCPU есть специальный регистр который называется указателем на инструкцию (\reg{IP}). Регистр \reg{IP} указывает на текущую выполняемую процессором инструкцию, и увеличивается по мере выполнения последующих инструкций.

Инструкции процессора могут быть либо переменной длины, либо постоянной длины, в зависимости от режима исполнения (см. стр \pageref{localexec}), поэтому указатель на инструкцию \reg{IP} может меняться с разным шагом. Можно напрямую задавать значение регистра \reg{IP} используя операции условного и безусловного перехода (см. стр \pageref{branching}).

Выполнение инструкций происходит следующим образом:
\begin{enumerate}
	\item Процессор считывает номер инструкции
	\item Если у инструкции есть операнды, то процессор считывает байт селектора регистр-память (см. \reg{rmbyte}). Если у инструкции нету операндов, и следующий байт нулевой, то он будет пропущен (это выполняется для совместимости со старыми версиями процессора).
	\item Номер инструкции декодируется, и считываются дополнительные байты сегментных префиксов (если они нужны, см. стр \pageref{instructionformat} для более детальной информации о их работе).
	\item Если нужно, то будут считаны дополнительные байты констант нужных для операнда.
	\item Процессор выполняет микрокод инструкции, который некоторым образом меняет состояние процессора (но при этом эти изменения кешируются, и не сразу записываются в регистры).
	\item Внутреннее состояние обновляется, и все записанные в кеш регистры переносяться в их реальные ячейки.
\end{enumerate}

Кеширование используется для оптимизации скорости работы процессора. На странице \pageref{caching} указан более детальный механизм кеширования.

Процессор выполняет постоянное количество циклов за секунду. Количество циклов необходимое для выполнения каждой отдельной инструкции может меняться. Полное количество циклов считается регистром \reg{TMR}. Почти все инструкции всего 1 цикл в длину, но из-за кеширования и доступа к памяти это число может меняться в значительных пределах.

См. стр \pageref{advexecution} для более детальной информации о процессе выполнения.

\section{Прерывания}
При возникновении некоторых особых событий в процессоре (например внешний сигнал, возникновение ошибки в арифметических операциях, и т.п.) процессор ZCPU сгенерирует прерывание. Прерывания - это особая функция процессора, которая временно "прерывает" его работу, изменяя выполнение программы что-бы выполнить обработчик события. При возникновении прерывания процессор заносит на свой стек адрес возврата в программу, и переходит к выполнению обработчика прерывания (см. стр \pageref{stack} для более подробной информации о стеке процессора).

В расширеном режиме процессор использует таблицу прерываний, в которой хранятся указатели на все функции-обработчики событий. Если расширенный режим не включён, то любое прерывание будет полностью останавливать процессор.

Каждое прерывание задаётся его номером, а также параметром прерывания - некоторым числом, которое несёт дополнительную информацию о прерывании.

После окончания выполнения обработчика прерывания состояние процессора будет восстановлено, и программа продолжит выполнение с места где возникло прерывание.

При возникновении прерывания процессор заносит на стек адрес возврата. Например если текущее значение указателя на инструкцию \reg{IP} есть 157, а состояние стека:
\begin{verbatim}
..........
65304: ...
65306: 181
65305: -94

ESP = 65304
\end{verbatim}
то после возникновения прерывания стек примет вид:
\begin{verbatim}
..........
65304: ...
65306: 181
65305: -94
65304: 0   CS
65303: 157 IP

ESP = 65302
\end{verbatim}
и указатель на инструкцию будет равен точке входа в обработчик прерываний.

Прерывания очень похожи на обычные вызовы подпрограмм (см. стр \pageref{branching}), но вместо использования прямого указателя процессору передаётся номер прерывания. Для возврата из обработчика нужно использовать специальную команду возврата \reg{IRET} (вместо обычной \reg{RET}). Любое прерывание можно вызвать вручную используя инструкцию \reg{INT}. Пример обработчика прерываний:
\begin{verbatim}
interrupt_handler:
  ....
iret;
\end{verbatim}

Существует два вида прерываний: внутренние прерывания (ошибки), и внешние прерывания. Внешние прерывания сохраняют состояние всех основных регистров процессора (вместе с данными для возврата из прерывания) перед выполнением обработчика. Они могут быть вызваны только через внешний вход для прерываний, или используя инструкцию \reg{EXTINT}. Внешние прерывания требуют использования инструкции \reg{EXTRET} для выхода из обработчика вместо \reg{IRET} как для обычных прерываний.

Есть несколько стандартных прерываний. Они будут вызваны если происходит некоторое внутреннее исключение. Все прерывания с номером ниже 32 зарезервированы для обработки ошибок процессора. Также прерывания 0 и 1 имеют специальное значение, и используются для перезапуска/выключения процессора. Прерывания 32..255 доступны для использования пользовательской программы. См. стр \pageref{errorcodes} для более детальной информации о кодах ошибок (номерах прерываний ошибок).

Эта таблица содержит все коды ошибок процессора:

\singlespacing
\begin{longtable}{|c|p{3.5in}|} \hline
Номер & Описание \\ \hline
0 & \emph{Сброс} \\ \hline
1 & \emph{Отключение} \\ \hline
2 & Конец выполнения программы \\ \hline
3 & Деление на ноль \\ \hline
4 & Неизвестная инструкция \\ \hline
5 & Внутренняя ошибка процессора \\ \hline
6 & Ошибка стека (переполнение/недополнение) \\ \hline
7 & Ошибка записи/чтения памяти \\ \hline
8 & Ошибка шины памяти \\ \hline
9 & Ошибка доступа записи (защита страницы памяти) \\ \hline
10 & Ошибка записи/чтения порта \\ \hline
11 & Ошибка доступа к странице (защита страницы памяти) \\ \hline
12 & Ошибка доступа чтения (защита страницы памяти) \\ \hline
13 & Общая ошибка процессора \\ \hline
14 & Ошибка исполнения (защита страницы памяти) \\ \hline
15 & Выход за пределы адресного пространства \\ \hline
17 & Ограничение количества инструкций (\emph{только GPU}) \\ \hline
23 & Ошибка чтения строки (\emph{только GPU}) \\ \hline
28 & \emph{Обработчик доступа чтения страницы} \\ \hline
29 & \emph{Обработчик доступа записи страницы} \\ \hline
30 & \emph{Обработчик доступа к странице} \\ \hline
31 & \emph{Обработчик шага отладки} \\ \hline
\end{longtable}
\onehalfspacing

Прерывание сброса (0) сбросит состояние процессора, и перезапустит выполнение кода с начала. Прерывание отключения (1) остановит выполнение кода пока процессор не будет перезапущен извне. Инструкции \texttt{int 1} и \texttt{int 0} будут правильно работать если они не обрабатываются процессором (т.е. если они отключены в таблице прерываний, или если таблицы прерываний отключена):
\begin{verbatim}
 INT 1; //Остановить выполнение

 INT 0; //Перезапустить процессора
\end{verbatim}

Если расширенный режим не включен, \emph{все прерывания} работают так-же как и прерывание остановки (\texttt{int 1}). Код ошибки будет послан на внешний выход кода ошибки.

Обработка прерываний может быть отключена флагом прерываний \reg{IF}. Этот регистр напрямую изменить нельзя, но его можно менять специальными инструкциями. \emph{При выставлении флага он будет выставлен только после следующей инструкции}. Например:

\begin{verbatim}
STI;         //Установить флаг прерываний
MOV EAX,123; //IF = 0
ADD EAX,123; //IF = 1 (флаг обновлён)
CLI;         //Убрать флаг прерываний
SUB EAX,123; //IF = 0 (флаг убран)
RET;         //IF = 0
\end{verbatim}

Это даёт возможность предотвратить ситуацию когда прерывание возникнет между инструкцией возврата и \texttt{STI}:

\begin{verbatim}
ContextSwitch:
  CLI;

  ... код ...

  STI;  //Прерывание никогда не возникнет между STI
EXTRET; //и NMIRET
\end{verbatim}

Для более детальной информации по работе таблицы прерываний см. страницу \pageref{advancedinterrupts}.

\section{Сегментация памяти и сегментные регистры} \label{segments}
В ZCPU есть 8 сегментных регистров. Это \reg{CS}, \reg{SS}, \reg{DS}, \reg{ES}, \reg{GS}, \reg{FS}, \reg{KS} и \reg{LS}. Они используются процессором для работы с разными моделями памяти. Также любые из 40 регистров общего назначения могут быть использованы как сегментные регистры.

Каждый сегментный регистр может хранить 48-битное целое число. Это значение может быть использовано для задание смещения для указателей при чтении/записи в память. Процессор всегда использует сегменты при обращении к памяти: он транслирует локальный адрес (который прямо задан пользователем) в абсолютный адрес (физический адрес ячейки в памяти).

Формула для трансляции адреса?
\[AbsoluteAddress = LocalAddress + SegmentOffset\]

Пользователь может задать регистр, который должен быть использован как сегментный, задавая его как префикс к инструкции. Если сегмент не указан, то по умолчанию используется сегмент \reg{DS}.

Как префикс можно использовать регистры общего назначения и сегментные регистры. Невозможно использовать число как сегментный префикс. Вот несколько разных примеров синтаксиса для чтения из памяти:
\begin{verbatim}
MOV EAX,#EBX      //Адрес: DS+EBX
MOV EAX,ES:#EBX   //Адрес: ES+EBX
MOV EAX,[EBX]     //Адрес: DS+EBX
MOV EAX,[ES:EBX]  //Адрес: ES+EBX
MOV EAX,[ES+EBX]  //Адрес: ES+EBX

MOV EAX,EBX:ECX   //Адрес: EBX+ECX
MOV EAX,[EBX+ECX] //Адрес: EBX+ECX
MOV EAX,[EBX:100] //Адрес: EBX+100
MOV EAX,[100:EBX] //Неправильный синтаксис
\end{verbatim}

Можно использовать сегментные префиксы для быстрого доступа к массивам данных, если использовать префикс как указатель на массив:
\begin{verbatim}
MOV ES,ArrayStart
MOV EAX,ES:#0 //EAX = 10
MOV EBX,ES:#2 //EBX = 30
MOV ECX,ES:#1 //ECX = 50

MOV EAX,0
MOV EBX,EAX:#ArrayStart //EBX = 10
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 50
INC EAX
MOV EBX,EAX:#ArrayStart //EBX = 30

ArrayStart: db 10,50,30
\end{verbatim}

Некоторые сегментные регистры используются процессором для особых целей, см. таблицу:

\singlespacing
\begin{longtable}{|c|c|p{3.0in}|} \hline
Регистр & Название & Описание \\ \hline
\texttt{CS} & Сегмент кода     & Код запускаеться из этого сегмента \\ \hline
\texttt{SS} & Сегмент данных   & Сегмент данных по умолчанию \\ \hline
\texttt{DS} & Сегмент стека    & Сегмент в котором хранится стек \\ \hline
\texttt{ES} & Доп. сегмент     & Пользовательский сегмент \\ \hline
\texttt{GS} & G-сегмент        & Пользовательский сегмент \\ \hline
\texttt{FS} & F-сегмент        & Пользовательский сегмент \\ \hline
\texttt{KS} & Ключевой сегмент & Пользовательский сегмент \\ \hline
\texttt{LS} & L-сегмент        & Пользовательский сегмент \\ \hline
\end{longtable}
\onehalfspacing

Все сегментные регистры кроме \reg{CS} можно задавать напрямую инструкцией \reg{MOV}. Единственный способ изменить регистр \reg{CS} это выполнить инструкцию \reg{CALLF} или \reg{JMPF} (см. стр \pageref{branching}):
\begin{verbatim}
//CS = 0
//IP = 928

JMPF 500,100;

//CS = 100
//IP = 500
\end{verbatim}

Если попытаться напрямую задать регистр \reg{CS} то будет вызвана ошибка \reg{13:1} (общая ошибка процессора). Например:
\begin{verbatim}
MOV DS,100
MOV ES,KS
MOV CS,1000 //Вызовет прерывание 13:1
\end{verbatim}

После сброса процессора все сегментные регистры будут сброшены в \reg{0}.

\section{Модели памяти}
Процессор ZCPU поддерживает несколько разных моделей памяти. По умолчанию используется режим линейной адресации памяти, и в этом режиме находиться процессор при его старте.

Разные модели памяти требуют разного использования регистров, и дают разные возможности по выполнению кода. Большинство режимов требует включенного расширенного режима процессора для получения функций расширенной защиты памяти, задания прав доступа к страницам, отображения памяти.

Важно знать как именно происходит доступ к памяти. При обращении к памяти процессора происходят такие операции:

\begin{enumerate}
	\item Проверка регистра \texttt{BusLock} (отключение шины)
	\item Проверка адреса - адрес должен быть 48-битным целым числом.
	\item Прочитать страницу, которая соответствует данному адресу.
	\item Если включен флаг \texttt{EF} (расширенный режим), то проверить что-бы текущий уровень доступа был меньше или равен уровня доступа страницы, к которой идёт обращение, и проверить флаги прав доступа страницы.
	\item Если у страницы выставлен флаг \texttt{Override} то войти в соответствующий режим перехвата обращения к памяти.
	\item Если у страницы выставлен флаг \texttt{Remapped} то правильно обработать отображение страницы в памяти.
	\item Выполнить операцию ввода/вывода.
\end{enumerate}

\subsection{Режим линейной адресации}
Это модель памяти по умолчанию, когда все сегментные регистры равны \reg{0}. Этот режим доступен сразу после запуска процессора. Поскольку все сегментные регистры равны нулю, то стек, данные, и код будут находиться в одном и том-же адресном пространстве.

В этом режиме не нужны сегментные префиксы. Например, можно напрямую обращаться к стеку:

\begin{verbatim}
MOV EAX,#0  //EAX будет равен 14 (номер инструкции MOV)
MOV #ESP,100 //Тоже PUSH 100
DEC ESP
POP EAX     //EAX будет равен 100
\end{verbatim}

\subsection{Режим сегментированой адресации}
В этом режиме адресации сегментные регистры используются для указания отдельных блоков для стека, данных, и кода. У такого подхода есть некоторые преимущества:

\begin{itemize}
  \item Позволяет предотвратить случайное повреждение данных/кода
  \item Один и тот-же код может использоваться для разных блоков данных
  \item Программы могут запускаться в локальном адресном пространстве
\end{itemize}

Example:
\begin{verbatim}
MOV DS,1000 //Установить первый блок данных
MOV SS,2000 //Установить первый блок стека
CALLF 0,500 //Вызвать подпрограмму (CS установлен в 500, IP в 0)

MOV DS,3000 //Установить второй блок данных
MOV SS,4000 //Установить второй блок стека
CALLF 0,500 //Вызвать ту-же подпрограмму, но с другим блоком данных
\end{verbatim}

Это запустит туже подпрограмму (по физическому адресу \reg{500}) используя два разных набора данных, то есть одна и та же подпрограмма может быть использована дважды для разных наборов переменных.

\subsection{Режим отображённой памяти}
Режим отображённой памяти использует возможности отображения памяти процессором для переназначения физических адресов которым соответствуют страницы. Это даёт возможность создать видимость одного целостного адресного пространства у каждого приложения. Это даёт возможность приложениям выделять блоки памяти, которые будут дополнены к адресному пространству.

См. стр \pageref{paging} для более детальной информации о возможностях процессора по отображению памяти.

\section{Стек} \label{stack}
В процессор Zyelios CPU встроен аппаратный стек для значений, который физически находится в памяти процессора. Состояние стека описывается состоянием стекового указателя \reg{ESP}, который указывает на следующую свободную ячейку памяти в стеке, регистра указывающего размер стеке (\reg{ESZ}) и стекового сегментного регистра (\reg{SS}).

\reg{ESP} указывает на \emph{следующую свободную ячейку стека}. Значения на стеке располагаются в последовательности уменьшения их адресов в памяти.

Для занесения и получения значений со стека используются инструкции \reg{PUSH} и \reg{POP} соответственно. При возникновении переполнения или недостатка стека будет вызвано прерывание \reg{6:ESP} (ошибка стека). Параметром прерывания будет \reg{ESP}. Например:

\begin{verbatim}
MOV SS,5000   //Стек начинается по адресу 5000
MOV ESP,2999  //И будет 3000 байт в размере
              //Следующим свободным адресом на стеке будет 2999
CPUSET 9,3000 //Установить регистр ESZ (размер стека)

PUSH 200
PUSH 100
POP EAX //EAX = 100
POP EBX //EBX = 200

//Инструкция PUSH X это тоже самое что:
MOV SS:#ESP,X
DEC ESP

//Инструкция POP Y это тоже самое что:
INC ESP
MOV Y,SS:#ESP
\end{verbatim}

Также можно использовать инструкции \reg{RSTACK} и \reg{SSTACK} для записи/чтения в произвольное место на стеке. Эти инструкции могут вызвать прерывания, которые сигнализируют ошибку стека. Вот пример использования этих инструкций:

\begin{verbatim}
RSTACK X,Y //X = MEMORY[SS+Y]
SSTACK X,Y //MEMORY[SS+X] = Y

RSTACK EAX,ESP:1 //Прочитать значение на вершине стека
RSTACK EAX,ESP:2 //Прочитать значение под вершиной

PUSH 100 //
PUSH 200 //Значение под вершиной
PUSH 300 //Значение на вершине

SSTACK ESP:2,123 //Установить значение под вершиной стека
POP EAX //EAX = 300
POP EBX //EBX = 123
POP ECX //ECX = 100
\end{verbatim}

\section{Подпрограммы} \label{branching}
Zyelios CPU поддерживает несколько способов изменения течения программы: условные и безусловные переходы, абсолютные и относительные. Указатель на инструкцию (\reg{IP}) указывает на инструкцию, которая сейчас выполняется. Все инструкции перехода меняют значение \reg{IP}; некоторые также меняют значение сегмента \reg{CS} (см. стр \pageref{segments}).

Самый простой тип переходов это абсолютный безусловный переход. Для того, что-бы его выполнить необходимо использовать инструкции \reg{JMP} или \reg{JMPF} (последняя также меняет \reg{CS}).

Подпрограммы могут быть вызваны используя инструкции \reg{CALL} или \reg{CALLF}. Это сохранит текущий указатель инструкции (и также \reg{CS} если используется \reg{CALLF}) на стек процессора. Указатель инструкции (и сегмент кода) могут быть восстановлены со стека используя инструкции \reg{RET} и \reg{RETF} соответственно.

Вот пример для иллюстрации переходов и подпрограмм:

\begin{verbatim}
JMPF MAIN,CODE_SEGMENT //Синтаксис JMPF IP,CS

......

MAIN: //Метка
  CALL SUBROUTINE
  JMP EXIT

SUBROUTINE:
  CALL SUBROUTINE2
RET //Выход из подпрограммы

SUBROUTINE2: //Вызвано внутри подпрограммы SUBROUTINE
  ... код ...
RET
......

EXIT:
\end{verbatim}

Также возможно совершать относительные переходы. Для этого используется инструкция \reg{JMPR} (jump relative). Эта инструкция прибавляет или отнимает от значения \reg{IP} некоторое число. Например:

\begin{verbatim}
JMPR +10 //Перейти на 10 байт вперёд
JMPR -10 //Перейти на 10 байт назад

JMPR LABEL-__PTR__ //Перейти к метке
                   //Метка __PTR__ указывает на текущий адрес инструкции

......

LABEL:
\end{verbatim}

Условные переходы позволяют менять течение программы в зависимости от выполнения разных условий. Инструкция \reg{CMP} используется для сравнения двух значений, и затем можно вызвать одну из указанных инструкций:

\singlespacing
\begin{longtable}{|c|c|p{3.0in}|} \hline
Инструкция & Операция & Описание \\ \hline
\texttt{JNE}   & X <> Y     & Переход если не равно \\ \hline
\texttt{JNZ}   & X - Y <> 0 & Переход если не ноль \\ \hline
\texttt{JG}    & X > Y      & Переход если больше чем \\ \hline
\texttt{JNLE}  & NOT X <= Y & Переход если не меньше or равно \\ \hline
\texttt{JGE}   & X >= Y     & Переход если больше or равно \\ \hline
\texttt{JNL}   & NOT X < Y  & Переход если не меньше чем\\ \hline
\texttt{JL}    & X < Y      & Переход если меньше чем \\ \hline
\texttt{JNGE}  & NOT X >= Y & Переход если не больше or равно \\ \hline
\texttt{JLE}   & X <= Y     & Переход если меньше or равно\\ \hline
\texttt{JNG}   & NOT X > Y  & Переход если не больше чем \\ \hline
\texttt{JE}    & X = Y      & Переход если равно \\ \hline
\texttt{JZ}    & X - Y = 0  & Переход если ноль \\ \hline

\texttt{CNE}   & X <> Y     & Вызов подпрограммы если не равно \\ \hline
\texttt{CNZ}   & X - Y <> 0 & Вызов подпрограммы если не ноль \\ \hline
\texttt{CG}    & X > Y      & Вызов подпрограммы если больше чем \\ \hline
\texttt{CNLE}  & NOT X <= Y & Вызов подпрограммы если не меньше or равно \\ \hline
\texttt{CGE}   & X >= Y     & Вызов подпрограммы если больше or равно \\ \hline
\texttt{CNL}   & NOT X < Y  & Вызов подпрограммы если не меньше чем\\ \hline
\texttt{CL}    & X < Y      & Вызов подпрограммы если меньше чем \\ \hline
\texttt{CNGE}  & NOT X >= Y & Вызов подпрограммы если не больше or равно \\ \hline
\texttt{CLE}   & X <= Y     & Вызов подпрограммы если меньше or равно\\ \hline
\texttt{CNG}   & NOT X > Y  & Вызов подпрограммы если не больше чем \\ \hline
\texttt{CE}    & X = Y      & Вызов подпрограммы если равно \\ \hline
\texttt{CZ}    & X - Y = 0  & Вызов подпрограммы если ноль \\ \hline

\texttt{JNER}   & X <> Y     & Относительный переход если не равно \\ \hline
\texttt{JNZR}   & X - Y <> 0 & Относительный переход если не ноль \\ \hline
\texttt{JGR}    & X > Y      & Относительный переход если больше чем \\ \hline
\texttt{JNLER}  & NOT X <= Y & Относительный переход если не меньше or равно \\ \hline
\texttt{JGER}   & X >= Y     & Относительный переход если больше or равно \\ \hline
\texttt{JNLR}   & NOT X < Y  & Относительный переход если не меньше чем\\ \hline
\texttt{JLR}    & X < Y      & Относительный переход если меньше чем \\ \hline
\texttt{JNGER}  & NOT X >= Y & Относительный переход если не больше or равно \\ \hline
\texttt{JLER}   & X <= Y     & Относительный переход если меньше or равно\\ \hline
\texttt{JNGR}   & NOT X > Y  & Относительный переход если не больше чем \\ \hline
\texttt{JER}    & X = Y      & Относительный переход если равно \\ \hline
\texttt{JZR}    & X - Y = 0  & Относительный переход если ноль \\ \hline

\end{longtable}
\onehalfspacing

Существуют и другие инструкции, которые производят проверку условий, например \reg{BIT}, которая тестирует состояние битов числа. Например:

\begin{verbatim}
CMP EAX,EBX
JG  LABEL1 //Переход если EAX >  EBX
JLE LABEL2 //Переход если EAX <= EBX
JE  LABEL3 //Переход если EAX  = EBX
CL  LABEL4 //Вызов подпрограммы если EAX <  EBX
CGE LABEL5 //Вызов подпрограммы если EAX >= EBX

BIT EAX,4 //Test 5th bit of EAX
JZ  LABEL1 //Переход если 5th bit is 0
JNZ LABEL1 //Переход если 5th bit is 1
\end{verbatim}

\section{Коды ошибок процессора}\label{errorcodes}
Есть несколько разных кодов ошибок, которые может сгенерировать процессор во время исполнения. При возникновении происходит прерывание по номеру ошибки.

Если процессор не в расширенном режиме, то выполнение кода прекращается когда возникает ошибка. При этом он выдаст код об ошибке на вывод \reg{ERROR}. В расширенном режиме процессор попытается вызвать обработчик прерывания, который соответствует этой ошибке.

Например, для обычной ошибки памяти код на выходе может быть \texttt{7.65536} (ошибка по адресу 65536).

Вывод кода ошибки будет сброшен в ноль при сбросе состояния процессора.

В процессоре есть такие коды ошибок:

\singlespacing
\begin{longtable}{|c|p{3.5in}|} \hline
Номер & Описание \\ \hline
2 & Конец выполнения программы \\ \hline
3 & Деление на ноль \\ \hline
4 & Неизвестная инструкция \\ \hline
5 & Внутренняя ошибка процессора \\ \hline
6 & Ошибка стека (переполнение/недополнение) \\ \hline
7 & Ошибка записи/чтения памяти \\ \hline
8 & Ошибка шины памяти \\ \hline
9 & Ошибка доступа записи (защита страницы памяти) \\ \hline
10 & Ошибка записи/чтения порта \\ \hline
11 & Ошибка доступа к странице (защита страницы памяти) \\ \hline
12 & Ошибка доступа чтения (защита страницы памяти) \\ \hline
13 & Общая ошибка процессора \\ \hline
14 & Ошибка исполнения (защита страницы памяти) \\ \hline
15 & Выход за пределы адресного пространства \\ \hline
17 & Ограничение количества инструкций (\emph{только GPU}) \\ \hline
23 & Ошибка чтения строки (\emph{только GPU}) \\ \hline
\end{longtable}
\onehalfspacing

\newcommand{\errorentry}[4]{\textbf{Сообщение}: #1 \newline \textbf{Возникает когда}: #2 \newline \textbf{Причина}: #3 \newline \textbf{Следствие}: #4 \newline \newline}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Окончание выполнения программы (02)}
\errorentry{Обнаружена инструкция STOP}
           {Выполнена операция \reg{STOP}}
           {Ненормальное завершение работы программы}
           {Отключение процессора}
\errorentry{Неизвестная инструкция}
           {Выполняется любая из инструкций перехода (\reg{JMP}, \reg{CALL}, и т.п.)}
           {Переход по адресу, который не указывает на корректную инструкцию процессора}
           {Отключение процессора}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Деление на ноль (03)}
\errorentry{Невозможно поделить на ноль}
           {Второй операнд в инструкции \reg{DIV} нулевой}
           {Ошибка в коде}
           {\reg{LADD = 0}}
\errorentry{Невозможно найти инверсию нуля}
           {Инструкция \reg{FINV} вызвана с нулевым операндом}
           {Ошибка в коде}
           {\reg{LADD = 1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Неизвестная инструкция (04)}
\errorentry{Обнаружена неизвестная инструкция в потоке выполнения}
           {Инструкция, которая выполняется процессором не есть известной инструкцией}
           {Неверное использование инструкций перехода (попытка выполнить данные как код)0}
           {\reg{LADD = номер инструкции}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Внутренняя ошибка процессора (05)}
\errorentry{Невозможно выполнить инструкцию (ошибка в микрокоде)}
           {Произошла внутренняя ошибка при выполнении микрокода инструкции}
           {Ошибка в логике процессора}
           {\reg{LADD = 01}}
\errorentry{Неизвестная внутренняя ошибка}
           {Никогда}
           {Нету}
           {\reg{LADD = 02}}
\errorentry{Ошибка чтения при декодировании инструкции}
           {Декодер инструкций не смог получить все нужные байты}
           {Переход за пределы физической/логической памяти}
           {\reg{LADD = 12}}
\errorentry{Ошибка чтения байта первого операнда}
           {Декодер инструкций не смог получить все нужные байты}
           {Переход за пределы физической/логической памяти}
           {\reg{LADD = 22}}
\errorentry{Ошибка чтения байта второго операнда}
           {Декодер инструкций не смог получить все нужные байты}
           {Переход за пределы физической/логической памяти}
           {\reg{LADD = 32}}
\errorentry{Неправильный селектор RM для первого операнда}
           {Никогда}
           {Нету}
           {\reg{LADD = 42}}
\errorentry{Неправильный селектор RM для второго операнда}
           {Никогда}
           {Нету}
           {\reg{LADD = 52}}
\errorentry{Невозможно записать в первый операнд}
           {Никогда}
           {Нету}
           {\reg{LADD = 62}}
\errorentry{Невозможно записать во второй операнд (только для \texttt{XCHG})}
           {Никогда}
           {Нету}
           {\reg{LADD = 72}}
\errorentry{Неизвестная инструкция}
           {Никогда}
           {Нету}
           {\reg{LADD = 82}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка стека (06)}
\errorentry{Ошибка переполнения стека}
           {Выполнена инструкция \reg{PUSH}}
           {Значение регистра \reg{ESP} становиться отрицательным}
           {\reg{LADD = 0}}
\errorentry{Ошибка недополнения стека}
           {Выполнена инструкция \reg{POP}}
           {Регистр \reg{ESP} становиться больше чем \reg{ESZ}}
           {\reg{LADD = ESZ}}
\errorentry{Ошибка чтения стека}
           {Выполнена инструкция \reg{POP}}
           {Невозможно прочитать значение из памяти}
           {\reg{LADD = ESP}}
\errorentry{Выход за пределы стека}
           {Выполнена инструкция \reg{RSTACK} или \reg{SSTACK}}
           {Указанное значение выходит за границы стека}
           {\reg{LADD} хранит ошибочный индекс}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка записи/чтения памяти (07)}
\errorentry{Ошибка чтения: адрес не существует}
           {Процессор попытался прочитать значение из внешней памяти}
           {К шине MemBus не подключено никакое устройство}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Ошибка чтения: невозможно прочитать адрес из памяти}
           {Процессор попытался прочитать значение из внешней памяти}
           {Произошла ошибка при чтении значения из памяти внешнего устройства (или страница не доступна для чтения)}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Ошибка записи: адрес не существует}
           {Процессор попытался записать значение в внешнюю память}
           {К шине MemBus не подключено никакое устройство}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Ошибка записи: невозможно записать в память по адресу}
           {Процессор попытался записать значение в внешнюю память}
           {Произошла ошибка при записи значения в памяти внешнего устройства (или страница не доступна для чтения)}
           {\reg{LADD} равен адресу к которому произошло обращение}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка шины памяти (08)}
\errorentry{Ошибка устройства}
           {Процессор попытался прочитать значение из внешней памяти}
           {Автобус сломался (bus fail): устройство подключенное к шине MemBus не поддерживает высокоскоростной интерфейс}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Ошибка устройства}
           {Процессор пытается прочитать значение из порта}
           {Автобус сломался (bus fail): устройство подключенное к шине IOBus не поддерживает высокоскоростной интерфейс}
           {\reg{LADD = -PORT\textunderscore NUMBER}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка доступа записи (09)}
\errorentry{Ошибка доступа}
           {Попытка записать значение в память}
           {Флаг \reg{EF} установлен в 1, страница к которой происходит доступ не имеет разрешения на  запись, и уровень доступа текущей страницы выше или равен уровню доступа запрашиваемой страницы}
           {\reg{LADD} равен адресу к которому произошло обращение}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка записи/чтения порта (10)}
\errorentry{Ошибка чтения: невозможно прочитать с порта}
           {Процессор попытался прочитать значение с порта}
           {Возникла ошибка при чтении с порта (адресу не назначено устройство)}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Ошибка записи: невозможно записать в порт}
           {Процессор попытался записать значение в порт}
           {Возникла ошибка при записи в порт (адресу не назначено устройство)}
           {\reg{LADD} равен адресу к которому произошло обращение}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка доступа к странице (11)}
\errorentry{Невозможно сделать страницу только для чтения}
           {Выполнена инструкций \reg{SPG}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}
\errorentry{Невозможно сделать страницу читаемой и записываемой}
           {Выполнена инструкций \reg{CPG}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}
\errorentry{Невозможно установить флаг страницы}
           {Выполнена инструкций \reg{SPP}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}
\errorentry{Невозможно убрать флаг страницы}
           {Выполнена инструкций \reg{CPP}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}
\errorentry{Невозможно изменить уровень доступа страницы}
           {Выполнена инструкций \reg{SRL}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}
\errorentry{Невозможно сменить настройки отображения страницы}
           {Выполнена инструкций \reg{SMAP}}
           {Текущий уровень доступа выше чем уровень доступа страницы, к которой идёт обращение}
           {\reg{LADD} указывает на страницу, к которой идёт обращение}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка доступа чтения (12)}
\errorentry{Ошибка доступа}
           {Попытка прочитать значение}
           {Флаг \reg{EF} установлен в 1, у страницы к которой идёт обращение нету прав на чтение, и уровень доступа текущей страницы превышает или равен уровню доступа страницы, с которой происходит чтение}
           {\reg{LADD} равен адресу к которому произошло обращение}
\errorentry{Страница за пределами постоянной памяти}
           {Использование инструкции \reg{ERPG}}
           {Страница не могла быть стёрта, поскольку она не находиться в постоянной памяти процессора}
           {\reg{LADD = 0}}
\errorentry{Страница за пределами постоянной памяти}
           {Использование инструкции \reg{WRPG}}
           {Страница не могла быть записана, поскольку она не находиться в постоянной памяти процессора}
           {\reg{LADD = 0}}
\errorentry{Страница за пределами постоянной памяти}
           {Использование инструкции \reg{RDPG}}
           {Страница не могла быть прочитана, поскольку она не находиться в постоянной памяти процессора}
           {\reg{LADD = 0}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Общая ошибка процессора (13)}
\errorentry{Невозможно записать сегмент кода}
           {Регистр \reg{CS} выступает в роли операнда, в который идёт запись результата}
           {Невозможно изменить сегментный регистр напрямую. Надо использовать инструкции \texttt{CALLF} ил \texttt{JMPF}}
           {\reg{LADD = 1}}
\errorentry{Невозможно прочитать таблицу прерываний}
           {Не удалось получить запись из таблицы прерываний}
           {Адрес таблицы, установленный инструкцией \reg{LIDTR}, не указывает на корректное место в памяти}
           {\reg{LADD = 2}}
\errorentry{Неправильный номер прерывания}
           {Номер прерывания находиться за пределами границ (0..255)}
           {Неправильное использование инструкций \reg{INT} или \reg{EXTINT}}
           {\reg{LADD = 3}}
\errorentry{Неразрешённый вызов внешнего прерывания}
           {У прерывания, которое вызывается извне, нету флага который разрешает вызов этого прерывания как внешнего}
           {\reg{6ой} бит не выставлен в флагах прерывания при вызове его как внешнего}
           {\reg{LADD = 4}}
\errorentry{Несовместимый режим}
           {Вызов прерывания в защищённом (совместимом) режиме с менее чем 512 байт памяти}
           {Недостаточно памяти для хранения таблицы прерываний}
           {\reg{LADD = 5}}
\errorentry{Невозможно записать данные о возврате прерывания}
           {Обработчик прерывания не смог записать данные о возврате на стек процессора}
           {Прерывание было вызвано при недостаточном месте на стеке}
           {\reg{LADD = 6}}
\errorentry{Невозможно вызвать прерывание}
           {Прерывание вызвано с недостаточными правами}
           {У обработчика прерывания недостаточно прав что-бы совершить переход}
           {\reg{LADD = 7}}
\errorentry{Невозможно прочитать таблицу страниц}
           {Таблица страниц не находиться в доступном адресном пространстве}
           {Таблица страниц не находиться в доступном адресном пространстве}
           {\reg{LADD = 8}}
\errorentry{Выполнение привилегированной инструкции}
           {Невозможно выполнить инструкцию из-за прав доступа}
           {Вызов одной из указанных инструкций без достаточных прав: \reg{RD}, \reg{WD}, \reg{SPG}, \reg{CPG}, \reg{STI}, \reg{CLI}, \reg{STP}, \reg{CLP}, \reg{STEF}, \reg{CLEF}, \reg{EXTINT}, \reg{ERPG}, \reg{WRPG}, \reg{RDPG}, \reg{LIDTR}, \reg{EXTRET}, \reg{IDLE}, \reg{STD2}, \reg{STM}, \reg{CLM}, \reg{CPUGET}, \reg{CPUSET}, \reg{CPP}, \reg{SPP}, \reg{SRL}, \reg{GRL}, \reg{SMAP}, \reg{GMAP}
}
           {\reg{LADD = Номер инструкции}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Ошибка исполнения (14)}
\errorentry{Ошибка доступа}
           {Попытка выполнить код на странице, в которой запрещено выполнять код}
           {Неправильная инструкция перехода}
           {\reg{LADD = номер страницы}}
\errorentry{Ошибка доступа}
           {Попытка выполнить код на странице, в которой запрещено выполнять код}
           {Выполнение кода пересекло границу между страницами}
           {\reg{LADD = номер страницы}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Выход за пределы адресного пространства (15)}
\errorentry{Выход за пределы адресного пространства}
           {Доступ к памяти по неправильному адресу}
           {Адрес не есть 48-битным целым знаковым числом}
           {\reg{LADD = неправильный адрес}}
