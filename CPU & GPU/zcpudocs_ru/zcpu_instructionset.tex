\newcommand{\intrentry}[3]{
  \newpage
  \subsection{#2 #1}
  \textbf{Мнемоника:} \texttt{#1} \ifthenelse{\number#3>0}{\texttt{X}}{}\ifthenelse{\number#3>1}{\texttt{,Y}}{} \\
  \textbf{Кодирование:} \texttt{#2} \ifthenelse{\number#3>0}{\texttt{RM [Сегмент1]}}{} \ifthenelse{\number#3>1}{\texttt{[Сегмент2]}}{} \ifthenelse{\number#3>0}{\texttt{[Данные1]}}{} \ifthenelse{\number#3>1}{\texttt{[Данные2]}}{}\\[0.7in]
}

\newcommand{\intrentrycat}[3]{
  \newpage
  \subsection{#2 #1}
  \textbf{Мнемоника:} \texttt{#1} \ifthenelse{\number#3>0}{\texttt{X}}{}\ifthenelse{\number#3>1}{\texttt{,Y}}{} \\
  \textbf{Кодирование:} \texttt{#2} \ifthenelse{\number#3>0}{\texttt{RM [Сегмент1]}}{} \ifthenelse{\number#3>1}{\texttt{[Сегмент2]}}{} \ifthenelse{\number#3>0}{\texttt{[Данные1]}}{} \ifthenelse{\number#3>1}{\texttt{[Данные2]}}{}\\[0.3in]
}

\newcommand{\intrpriv}[0]{
  Данная инструкция привилегированна, то есть она может быть исполнена лишь когда текущий уровень доступа равен 0.
  
}

\newcommand{\intrerror}[1]{
  \ifthenelse{\number#1=3}{
    Может вызвать ошибку \reg{3} (деление на ноль) если второй операнд равен нулю.
    
  }{}  
  \ifthenelse{\number#1=6}{
    Может вызвать ошибку \reg{6} (переполнение/недополнение стека) если указатель стека выйдет за допустимые пределы.
    
  }{}
  \ifthenelse{\number#1=7}{
    Может вызвать ошибку \reg{7} (ошибка чтения/записи памяти) если инструкция не смогла выполнить необходимую запись в память.
    
  }{}
  \ifthenelse{\number#1=11}{
    Может вызвать ошибку \reg{11} (ошибка доступа к странице) если инструкция обращаеться к странице, к которой нету прав доступа (уровень доступа текущей страницы больше чем уровень доступа страницы, над которой производится операция).
    
  }{}  
  \ifthenelse{\number#1=14}{
    Может вызвать ошибку \reg{14} (ошибка прав на выполнение кода) если будет осуществлён переход по адресу, который находиться в защищённой области памяти при включенном расширенном режиме. См. стр \pageref{paging} для более детальной информации о механизме страниц и защиты памяти.
    
  }{}
}


\chapter{Список инструкций процессора} \label{opcodelist}
\section{Основной набор инструкций ZCPU}
В этой секции описан основной набор инструкций, доступных для использования в ZCPU. Некоторые из указанных инструкций не могут быть использованы в производных от ZCPU архитектурах (ZGPU, ZSPU). Недоступны указанные инструкции: \reg{EXTINT}

Для некоторых инструкций указаны ошибки, которые могут быть ими вызваны, исключая ошибки которые могут быть вызваны декодированием инструкции, например если один из операндов это указатель на чтение из памяти.


\intrentry{STOP}{000}{0}
Вызывает прерывание \char`\#2 (тоже самое что выполнение \reg{INT 2}). Останавливает выполнение программы процессором, если расширенный режим не включен.

Используется для обнаружения конца программы/некорректного перехода, поскольку часто является следствием некорректного перехода по адресу. Работает как \reg{NOP} если система прерываний отключена (флаг \reg{IF} установлен в 0).

\textbf{Псевдокод:}
\begin{verbatim}
Interrupt(2,0)
\end{verbatim}


\intrentry{JNE/JNZ}{001}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения значения были не равны друг другу.

Также данная инструкция может быть использована для проверки установленности бита числа:
\begin{verbatim}
BIT EAX,2
JNZ LABEL
\end{verbatim}

Переход будет осуществлён только когда бит равен единице.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR <> 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{JMP}{002}{1}
Безусловный переход по заданному адресу.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
Jump(X)
\end{verbatim}


\intrentry{JG/JNLE}{001}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было больше второго.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR > 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{JGE/JNL}{004}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было больше или равно второму.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR >= 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{JL/JNGE}{005}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было меньше второго.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR < 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{JLE/JNG}{006}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения первое значение было меньше или равно второму.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR <= 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{JE/JZ}{007}{1}
Осуществляет условный переход по заданному адресу если в результате предыдущего сравнения значения были равны.

Также даная инструкция может быть использована для проверки установленности бита числа:
\begin{verbatim}
BIT EAX,2
JZ LABEL
\end{verbatim}

Переход будет осуществлён только когда бит равен нулю.

\intrerror{14}

\textbf{Псевдокод:}
\begin{verbatim}
if CMPR <> 0 then
  Jump(X)
end
\end{verbatim}


\intrentry{CPUID}{008}{1}
Инструкция \reg{CPUID} позволяет получить информацию о текущей версии процессора, и его возможностям. Результат будет записан в регистр \reg{EAX}.

Параметр инструкции указывает какую информацию нужно получить:

\singlespacing
\begin{longtable}{|c|p{3.5in}|} \hline
Параметр & Описание \\ \hline
0 & Текущая версия процессора (10.00, записывается как \reg{1000}) \\ \hline
1 & Количество внутренней оперативной памяти в байтах \\ \hline
2 & Тип процессора \\ \hline
3 & Количество внутренней постоянной памяти в байтах \\ \hline
\end{longtable}
\onehalfspacing

Результат будет записан в регистр \reg{EAX}. Тип процессора может указывать на:
\singlespacing
\begin{longtable}{|c|p{2.5in}|} \hline
\reg{EAX} & Описание \\ \hline
0 & ZCPU \\ \hline
1 & ZGPU (бета версия) \\ \hline
2 & ZSPU \\ \hline
3 & ZGPU \\ \hline
\end{longtable}
\onehalfspacing

\textbf{Псевдокод:}
\begin{verbatim}
EAX = CPUID[X]
\end{verbatim}


\intrentry{PUSH}{009}{1}
Отсылает значение на стек процессора (см. стр \pageref{stack} для более детальной информации о работе стека процессора). Также будет проведена проверка на ошибку выхода за пределы стека (проверка перехода указателя стека через ноль).

Как указатель на стек используется регистр \reg{ESP}, а как размер стека - регистр \reg{ESZ}.

Пример использования:
\begin{verbatim}
PUSH 10
PUSH 20

POP EAX //EAX теперь равен 20
\end{verbatim}

\intrerror{6}
\intrerror{7}

\textbf{Псевдокод:}
\begin{verbatim}
MEMORY[ESP+SS] = X
ESP = ESP - 1

if ESP < 0 then
  ESP = 0
  Interrupt(6,ESP)
end
\end{verbatim}


\intrentry{ADD}{010}{2}
Находит сумму двух значений, и записывает результат в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = X + Y
\end{verbatim}


\intrentry{SUB}{011}{2}
Отнимает второй операнд от первого, и записывает результат в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = X - Y
\end{verbatim}


\intrentry{MUL}{012}{2}
Множит два значения между собой, и записывает результат в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = X * Y
\end{verbatim}


\intrentry{DIV}{013}{2}
Делит первый операнд на второй, и записывает результат в первый операнд. Также проверяет второй операнд на равность нулю.

\intrerror{3}

Ошибка будет проигнорирована если отключены прерывания.

\textbf{Псевдокод:}
\begin{verbatim}
if Y <> 0 then
  X = X / Y
else
  Interrupt(3,0)
end
\end{verbatim}


\intrentry{MOV}{014}{2}
Копирует содержимое второго операнда в первый.

\textbf{Псевдокод:}
\begin{verbatim}
X = Y
\end{verbatim}


\intrentry{CMP}{015}{2}
Сравнивает два значения, и запоминает результат этого сравнения.

Эта инструкция используется вместе с инструкциями условного перехода (см. стр \pageref{branching}), например:
\begin{verbatim}
CMP EAX,EBX
JG  LABEL1 //Переход, если EAX >  EBX
JLE LABEL2 //Переход, если EAX <= EBX
JE  LABEL3 //Переход, если EAX  = EBX
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
CMPR = X - Y
\end{verbatim}


\intrentry{MIN}{018}{2}
Записывает меньшее из двух значений в первый операнд, например:
\begin{verbatim}
MOV EAX,100
MOV EBX,200
MIN EBX,EAX //Записывает 100 в EBX
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
if X > Y then
  X = Y
end
\end{verbatim}


\intrentry{MAX}{019}{2}
Записывает большее из двух значений в первый операнд, например:
\begin{verbatim}
MOV EAX,100
MOV EBX,200
MAX EAX,EBX //Записывает 200 в EAX
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
if X < Y then
  X = Y
end
\end{verbatim}


\intrentry{INC}{020}{1}
Увеличивает операнд на единицу, например:
\begin{verbatim}
MOV EAX,100
INC EAX //EAX теперь равен 101
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = X + 1
\end{verbatim}


\intrentry{DEC}{021}{1}
Уменьшает операнд на единицу, например:
\begin{verbatim}
MOV EAX,100
DEC EAX //EAX теперь равен 99
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = X - 1
\end{verbatim}



\intrentry{NEG}{022}{1}
Меняет знак операнда на противоположный. Например:
\begin{verbatim}
MOV EAX,123
NEG EAX //EAX теперь равен -123

MOV EBX,0
NEG EBX //EBX теперь равен -0, нуль со знаком
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = -X
\end{verbatim}


\intrentry{RAND}{023}{1}
Аппаратно генерирует случайное число в интервале от 0.0 до 1.0, включительно.

\textbf{Псевдокод:}
\begin{verbatim}
X = RANDOM(0.0,1.0)
\end{verbatim}


\intrentry{LOOP}{024}{1}
Выполняет условный переход по заданному адресу если регистр ECX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
\begin{verbatim}
MOV ECX,100;
LABEL:
  <...>
LOOP ECX; //Повторяет 100 раз
\end{verbatim}

Цикл будет остановлен только когда ECX станет равным нулю.

\textbf{Псевдокод:}
\begin{verbatim}
if ECX <> 0 then
  ECX = ECX - 1
  IP = X
end
\end{verbatim}


\intrentry{LOOPA}{025}{1}
Выполняет условный переход по заданному адресу если регистр EAX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
\begin{verbatim}
MOV EAX,100;
LABEL:
  <...>
LOOP EAX; //Повторяет 100 раз
\end{verbatim}

Цикл будет остановлен только когда EAX станет равным нулю. Аналогичен инструкции \reg{LOOP}.

\textbf{Псевдокод:}
\begin{verbatim}
if EAX <> 0 then
  EAX = EAX - 1
  IP = X
end
\end{verbatim}


\intrentry{LOOPB}{026}{1}
Выполняет условный переход по заданному адресу если регистр EBX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
\begin{verbatim}
MOV EBX,100;
LABEL:
  <...>
LOOP EBX; //Повторяет 100 раз
\end{verbatim}

Цикл будет остановлен только когда EBX станет равным нулю. Аналогичен инструкции \reg{LOOP}.

\textbf{Псевдокод:}
\begin{verbatim}
if EBX <> 0 then
  EBX = EBX - 1
  IP = X
end
\end{verbatim}


\intrentry{LOOPD}{027}{1}
Выполняет условный переход по заданному адресу если регистр EDX не равен нулю. Обычно используеться для создания циклов с конечным числом повторений:
\begin{verbatim}
MOV EDX,100;
LABEL:
  <...>
LOOP EDX; //Повторяет 100 раз
\end{verbatim}

Цикл будет остановлен только когда EDX станет равным нулю. Аналогичен инструкции \reg{LOOP}.

\textbf{Псевдокод:}
\begin{verbatim}
if EDX <> 0 then
  EDX = EDX - 1
  IP = X
end
\end{verbatim}


\intrentry{SPG}{028}{1}
Делает заданную страницу доступной только для чтения. Инструкция убирает флаг возможности записи, и выставляет флаг возможности чтения страницы указанной операндом. См. стр \pageref{paging} для более детальной информации о системе страниц.

Например:
\begin{verbatim}
SPG 1 //Сделать адреса 128..255 доступными только для чтения
SPG 2 //Сделать адреса 256..511 доступными только для чтения

CPG 1 //Сделать адреса 128..255 доступными для чтения и записи
\end{verbatim}

\intrerror{11}

В случае ошибки номер страницы, настройки которой менялись инструкцией, будет передан как параметр прерывания (регистр \reg{LADD}).

\textbf{Псевдокод:}
\begin{verbatim}
if CurrentPage.Runlevel < Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 0
else
  Interrupt(11,X)
end
\end{verbatim}


\intrentry{CPG}{029}{1}
Делает заданную страницу доступной для чтения и записи. Инструкция выставляет флаг возможности записи, и возможности чтения страницы указанной операндом. См. стр \pageref{paging} для более детальной информации о системе страниц.

Например:
\begin{verbatim}
SPG 1 //Сделать адреса 128..255 доступными только для чтения
SPG 2 //Сделать адреса 256..511 доступными только для чтения

CPG 1 //Сделать адреса 128..255 доступными для чтения и записи
\end{verbatim}

\intrerror{11}

В случае ошибки номер страницы, настройки которой менялись инструкцией, будет передан как параметр прерывания (регистр \reg{LADD}).

\textbf{Псевдокод:}
\begin{verbatim}
if CurrentPage.Runlevel < Page[X].Runlevel then
  Page[X].Read = 1
  Page[X].Write = 1
else
  Interrupt(11,X)
end
\end{verbatim}


\intrentry{POP}{030}{1}
Убирает значение с вершины стеке процессора, и записывает его в операнд (см. стр \pageref{stack} для более подробной информации о работе стека процессора). Проверяет ошибку недополнения стека сравнивая значение нового указателя стека, и регистра размера стека.

Использует регистр \reg{ESP} как указатель стека, и регистр \reg{ESZ} для размера стека.

Пример использования:
\begin{verbatim}
PUSH 10
PUSH 20

POP EAX //EAX теперь равен 20
\end{verbatim}

\intrerror{6}

\textbf{Псевдокод:}
\begin{verbatim}
ESP = ESP + 1
if ESP > ESZ then
  ESP = ESZ
  Interrupt(6,ESP)
end
\end{verbatim}


\intrentry{CALL}{031}{1}
Вызывает подпрограмму. Выполнение основной программы будет продолжено из этого самого момента после возвращения из подпрограммы используя инструкцию \reg{RET}.

Эта инструкция сохраняет текущий указатель на инструкцию \reg{IP} на стек (адрес возврата), и восстанавливает его при вызове соответствующей инструкции \reg{RET}. Повреждение или нарушение работы стека вызовет ошибку при возврате из функции.

Данная инструкция может вызвать ошибку стека, если на стеке недостаточно места для сохранения адреса возврата.

Например:
\begin{verbatim}
CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
RET

SUBROUTINE1:
  CALL SUBROUTINE0;
RET
\end{verbatim}

\intrerror{6}

\textbf{Псевдокод:}
\begin{verbatim}
Push(IP)
if NoInterrupts then
  IP = X
end
\end{verbatim}


\intrentry{BNOT}{032}{1}
Меняет все биты числа на противоположные. Количество бит которые будут затронуты зависит от текущего значения регистра \reg{BPREC} (точность двоичных операций).

Например:
\begin{verbatim}
CPUSET 50,8 //Выставить 8-битную точность

MOV EAX,1
BNOT EAX //EAX теперь равен 254
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = NOT X
\end{verbatim}


\intrentry{FINT}{033}{1}
Округляет значение вниз (до меньшего целого числа):
\begin{verbatim}
MOV EAX,1.9
FINT EAX //EAX = 1.0

MOV EAX,4.21
FINT EAX //EAX = 4.0

MOV EAX,1520.101
FINT EAX //EAX = 1520.0
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = FLOOR(X)
\end{verbatim}


\intrentry{FRND}{034}{1}
Округляет значение за правилом округления (до более близкого целого числа):
\begin{verbatim}
MOV EAX,1.9
FRND EAX //EAX = 2.0

MOV EAX,4.21
FRND EAX //EAX = 4.0

MOV EAX,1520.101
FRND EAX //EAX = 1520.0
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = ROUND(X)
\end{verbatim}


\intrentry{FFRAC}{035}{1}
Возвращает дробную часть операнда:
\begin{verbatim}
MOV EAX,1.9
FRND EAX //EAX = 0.9

MOV EAX,4.21
FRND EAX //EAX = 0.21

MOV EAX,1520.101
FRND EAX //EAX = 0.101
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = FRAC(X)
\end{verbatim}


\intrentry{FINV}{036}{1}
Находит значение, обратное операнду. Проверяет на возникновение ошибки деления на ноль.

\intrerror{3}

Ошибка деления на ноль вызвана не будет если регистр \reg{IF} (флаг прерываний) выставлен в 0.

\textbf{Псевдокод:}
\begin{verbatim}
if X <> 0 then
  X = 1 / X
else
  Interrupt(3,1)
end
\end{verbatim}


\intrentry{FSHL}{038}{1}
Производит арифметический сдвиг влево домножая заданное число на два. В результате может быть получено число с плавающей точкой:
\begin{verbatim}
MOV EAX,100
FSHR EAX //EAX = 200

MOV EAX,8
FSHR EAX //EAX = 16

MOV EAX,4.2
FSHR EAX //EAX = 8.2
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = X * 2
\end{verbatim}


\intrentry{FSHR}{039}{1}
Производит арифметический сдвиг вправо деля заданное число на два. В результате может быть получено число с плавающей точкой:
\begin{verbatim}
MOV EAX,100
FSHR EAX //EAX = 50

MOV EAX,8
FSHR EAX //EAX = 4

MOV EAX,4.2
FSHR EAX //EAX = 2.1
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
X = X / 2
\end{verbatim}


\intrentry{RET}{040}{0}
Возвращается из подпрограммы вызванной инструкцией \reg{CALL}. Эта инструкция убирает с вершины стека адрес возврата, и записывает его в регистр \reg{IP} (указатель на инструкцию).

Обычно используется для создания подпрограмм:
\begin{verbatim}
CALL SUBROUTINE0;
CALL SUBROUTINE1;

SUBROUTINE0:
  <...>
RET

SUBROUTINE1:
  <...>
  CALL SUBROUTINE0;
RET
\end{verbatim}

\intrerror{6}

\textbf{Псевдокод:}
\begin{verbatim}
IP = POP()
\end{verbatim}


\intrentry{IRET}{041}{0}
Данная инструкция возвращается из выполнения обработчика прерывания. Она работает таким-же образом как и инструкция \reg{RET}, только восстанавливает и сегмент кода\reg{CS}, и указатель на инструкцию \reg{IP}. Оба значения будут сняты со стека.

Восстановленное значение сегмента кода соответствует сегменту, в котором выполнялся код на момент возникновения прерывания. Данная инструкция не зависит от флага прерываний \reg{IF}.

Например тело обработчика прерывания может быть вот таким:
\begin{verbatim}
INTERRUPT_HANDLER:
  <...>
IRET;
\end{verbatim}

\textbf{Псевдокод:}
\begin{verbatim}
if EF = 0 then
  IP = Pop()
end
if EF = 1 then
  CS = Pop()
  IP = Pop()
end
\end{verbatim}


\intrentry{STI}{042}{0}
Устанавливает флаг прерываний \reg{IF} в 1 \emph{после следующей инструкции}. Это включит возможность обработки прерываний (без этого прерывания будут пропускаться).

Задержка в одну инструкцию создана для того, что-бы можно было скомбинировать инструкцию \reg{STI} вместе с \reg{IRET} или \reg{EXTRET} для обеспечения корректного выхода из обработчика прерывания (что-бы прерывание не возникло до того, как будет выход из обработчика).

Например:
\begin{verbatim}
INTERRUPT_HANDLER:
  CLI;
  <...>
  STI;
EXTRET;
\end{verbatim}

\intrpriv

\textbf{Псевдокод:}
\begin{verbatim}
NextIF = 1
\end{verbatim}


\intrentry{CLI}{043}{0}
Очищает флаг прерываний \reg{IF}. Это предотвратит вызов любых прерываний, они будут просто игнорироваться. Обработку прерываний снова можно включить используя инструкцию \reg{STI}.

\intrpriv

\textbf{Псевдокод:}
\begin{verbatim}
IF = 0
\end{verbatim}


\intrentry{RETF}{047}{0}
Производит дальний возврат из подпрограммы, которая была вызвана с помощью инструкции \reg{CALLF}. Работает схожим образом с инструкцией \reg{IRET}.

Значения текущего сегмента кода и указателя инструкций будут взяты с вершины стека.

\textbf{Псевдокод:}
\begin{verbatim}
CS = Pop()
IP = Pop()
\end{verbatim}

\intrentry{STEF}{048}{0}
Включает расширенный режим процессора. В этом режиме включается поддержка таблицы прерываний и проверок связанных с защитой памяти для страниц.

Система страниц не зависит от работы расширенного режима, и может работать с выключенным защищённым режимом.

Возможно отключить расширенный режим с помощью инструкции \reg{CLEF}.

\intrpriv

\textbf{Псевдокод:}
\begin{verbatim}
EF = 1
\end{verbatim}


\intrentry{CLEF}{049}{0}
Выключает расширенный режим, который был включен инструкцией \reg{STEF}. Это отключит таблицу прерываний и проверки прав доступа при обращении к страницам памяти.

Система страниц не зависит от работы расширенного режима, и может работать с выключенным защищённым режимом.

\intrpriv

\textbf{Псевдокод:}
\begin{verbatim}
EF = 0
\end{verbatim}


\intrentry{AND}{050}{2}
Производит логическую операцию И. В первый операнд будет записана единица если оба операнда больше или равны единице, иначе будет записан ноль.

\textbf{Псевдокод:}
\begin{verbatim}
X = X AND Y
\end{verbatim}


\intrentry{OR}{051}{2}
Производит логическую операцию ИЛИ. В первый операнд будет записана единица если один из операндов больше или равен единице, иначе будет записан ноль.

\textbf{Псевдокод:}
\begin{verbatim}
X = X OR Y
\end{verbatim}


\intrentry{XOR}{052}{2}
Производит логическую операцию исключающего ИЛИ. В первый операнд будет записана единица если один из операндов больше или равен единице, но только один, иначе будет записан ноль.

\textbf{Псевдокод:}
\begin{verbatim}
X = X XOR Y
\end{verbatim}


\intrentry{FSIN}{053}{2}
Записывает синус второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = Sin(Y)
\end{verbatim}


\intrentry{FCOS}{054}{2}
Записывает косинус второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = Cos(Y)
\end{verbatim}


\intrentry{FTAN}{055}{2}
Записывает тангенс второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = Tan(Y)
\end{verbatim}


\intrentry{FASIN}{056}{2}
Записывает арксинус второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = ArcSin(Y)
\end{verbatim}


\intrentry{FACOS}{057}{2}
Записывает арккосинус второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = ArcCos(Y)
\end{verbatim}


\intrentry{FATAN}{058}{2}
Записывает арктангенс второго операнда в первый операнд.

\textbf{Псевдокод:}
\begin{verbatim}
X = ArcTan(Y)
\end{verbatim}


\intrentry{MOD}{059}{2}
Находит остаток от деления первого операнда на второй. Если на входе число с плавающей точкой, то записано будет число $X - n * Y$, где $n$ это результат деления of $X / Y$ округлённый в сторону нуля.

\textbf{Псевдокод:}
\begin{verbatim}
X = X FMOD Y
\end{verbatim}
